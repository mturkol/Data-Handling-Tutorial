
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>demoENG101</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-03-05"><meta name="DC.source" content="demoENG101.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Loading and displaying data</a></li><li><a href="#3">Plotting data</a></li><li><a href="#4">Making a scenario: Random missing values in data</a></li><li><a href="#5">Replacing data with missing values</a></li><li><a href="#6">Pre-process, clean and interpolate data</a></li><li><a href="#7">Computing RMS Error of interpolation with vectorized vs. looped code</a></li></ul></div><pre class="codeinput"><span class="comment">%==========================================================================</span>
<span class="comment">% Name        : demoENG101.m</span>
<span class="comment">% Author      : Mert Turkol</span>
<span class="comment">% Date        : 07/30/2018</span>
<span class="comment">% Copyright   : GNU General Public License</span>
<span class="comment">% Description : This script executes the statements and expressions</span>
<span class="comment">%               presented in the video demonstration for ENG101 GSI</span>
<span class="comment">%               application. The examples demonstrated by this code</span>
<span class="comment">%               mainly cover simple yet important Data Handling</span>
<span class="comment">%               basics. During the demo we will also talk about</span>
<span class="comment">%               various topics like array manipulation, random#</span>
<span class="comment">%               generation and logical indexing as well as some</span>
<span class="comment">%               efficient code-writing practices (i.e. vectorization)</span>
<span class="comment">%==========================================================================</span>
</pre><h2 id="2">Loading and displaying data</h2><p>Load some data from a space-delimited file that comes preinstalled with MATLAB: Three sets of hourly traffic counts, recorded at three different town intersections over a 24-hour period.</p><pre class="codeinput">rawData = load(<span class="string">'count.dat'</span>); <span class="comment">%also works for comma-separated txt files</span>
<span class="comment">% for excel spreadsheets, use: xlsData = xlsread('someFile.xls') or</span>
<span class="comment">% for csv comma-separated files, use: csvData = csvread('someFile.csv')</span>
whos <span class="string">rawData</span> <span class="comment">%list chosen variable name, size and type</span>
disp(rawData) <span class="comment">%display the data</span>
</pre><pre class="codeoutput">  Name          Size            Bytes  Class     Attributes

  rawData      24x3               576  double              

    11    11     9
     7    13    11
    14    17    20
    11    13     9
    43    51    69
    38    46    76
    61   132   186
    75   135   180
    38    88   115
    28    36    55
    12    12    14
    18    27    30
    18    19    29
    17    15    18
    19    36    48
    32    47    10
    42    65    92
    57    66   151
    44    55    90
   114   145   257
    35    58    68
    11    12    15
    13     9    15
    10     9     7
</pre><h2 id="3">Plotting data</h2><pre class="codeinput">[nRow, nCol] = size(rawData);
t = (1:nRow)'; <span class="comment">%time vector with unit hourly increments</span>
<span class="comment">% General expression for 'n' samples between 'tStart' and 'tFinal' is:</span>
<span class="comment">% t = tStart:(tFinal-tStart)/(n-1):tFinal;</span>
hRaw = plot(t, rawData, <span class="string">'-*'</span>, <span class="string">'LineWidth'</span>, 2); <span class="comment">%store plot handle</span>
graphName = <span class="string">'Traffic Count Data'</span>; title(graphName);
xAxisName = <span class="string">'Time [h]'</span>; xlabel(xAxisName),
yAxisName = <span class="string">'Vehicle Count'</span>; ylabel(yAxisName),
lineName = [<span class="string">'Intersection 1'</span>; <span class="string">'Intersection 2'</span>; <span class="string">'Intersection 3'</span>];
legend(lineName, <span class="string">'Location'</span>, <span class="string">'north'</span>);
</pre><img vspace="5" hspace="5" src="demoENG101_01.png" alt=""> <h2 id="4">Making a scenario: Random missing values in data</h2><p>Let's randomly contaminate data by replacing two entries in each column with 'NaN's (Not-a-Number) on purpose to simulate missing data behavior. 'NaN's appear as a result of undefined operation, such as 0/0.</p><pre class="codeinput">SEEDVAL = 734; rng(SEEDVAL); <span class="comment">%set random seed for repeatibility</span>
NMISS = 2; rndmSubs = randi([2 nRow-1], [NMISS nCol]);
<span class="comment">% randi([startVal endVal], [size1 size2 ... sizeN] draws random ints</span>
<span class="comment">% from the uniform distribution btwn. startVal - endVal, and returns</span>
<span class="comment">% [size1 x ... x sizeN] array.</span>

<span class="comment">% NOTE: 'rand()' draws real numbers from the uni. distro., whereas</span>
<span class="comment">%       'randn()' does the same from normal distro.</span>

<span class="comment">% Along the same column, we would like two row-subscripts chosen</span>
<span class="comment">% randomly to be different to prevent replacing the same entry twice.</span>
<span class="comment">% First, take successive differences along the rows of 'rndmSubs'.</span>
isUnique = all( diff(rndmSubs) );
<span class="comment">% The resulting row vector is then evaluated and returns '1'</span>
<span class="comment">% if and only if ALL differences are non-zero. This will be the</span>
<span class="comment">% loop condition to make sure we have unique row-subscripts</span>
<span class="comment">% selected along each column.</span>

<span class="comment">% NOTE: any( x ) returns 1 if ANY entry is nonzero</span>

<span class="keyword">while</span>(~isUnique) <span class="comment">%iterate until condition is false</span>
  disp(<span class="string">'Random matrix of integer subscripts with equal values along column(s):'</span>);
  disp(rndmSubs);
  <span class="comment">%randomly shuffle the array:</span>
  rndmSubs = rndmSubs( randperm( numel(rndmSubs) ) );
  <span class="comment">%reshape vector into a matrix:</span>
  rndmSubs = reshape(rndmSubs, NMISS, []);
  <span class="comment">%assign the new value of loop-variable:</span>
  isUnique = all( diff(rndmSubs) );
<span class="keyword">end</span>

<span class="comment">% We randomly chose two integer subscripts in the [2, 23] interval</span>
<span class="comment">% to replace two entries with corresponding row indices along each</span>
<span class="comment">% column of rawData. rndmSubs is of size [2x3] and has non-equal</span>
<span class="comment">% integers within each column.</span>
disp(<span class="string">'Unique integer subscripts to replace with NaNs in each column: '</span>);
disp(rndmSubs);

<span class="comment">% Alteratively, we could display our matrix of random integers</span>
<span class="comment">% that are unique per column, with fprintf() :</span>
<span class="comment">% fprintf( [ '\nUnique integer subscripts to replace with NaNs ', ...</span>
<span class="comment">%            'in each column: \n', ...</span>
<span class="comment">%            repmat('\t\t%d  %d  %d\n', 1, NMISS) ], rndmSubs' );</span>
</pre><pre class="codeoutput">Random matrix of integer subscripts with equal values along column(s):
    19    10    19
     9    10    21
Unique integer subscripts to replace with NaNs in each column: 
    10     9    21
    19    19    10
</pre><h2 id="5">Replacing data with missing values</h2><pre class="codeinput">missData = rawData; <span class="comment">%define a new data matrix same as the original</span>
<span class="keyword">for</span> iCol = 1:nCol <span class="comment">%loop over columns of data</span>
 missData( rndmSubs(:,iCol), iCol ) = nan; <span class="comment">%replace with NaN</span>
<span class="keyword">end</span>
</pre><h2 id="6">Pre-process, clean and interpolate data</h2><p>We will now plot the data with missing values to see what it looks like. Assuming no previous knowledge about the contaminated data's content (except its size), we will identify where the missing values are. Final step will be to clean those values and estimate w/ linear interpolation.</p><pre class="codeinput">hold <span class="string">on</span>; delete(hRaw);  legend(<span class="string">'off'</span>); plot(t, missData, <span class="string">'-*'</span>, <span class="string">'LineWidth'</span>, 2);
title( horzcat(<span class="string">'Missing '</span>, graphName) ); hold <span class="string">off</span>;

hasNan = any( isnan( missData(:) ) ); <span class="comment">%logical to check for NaNs</span>
<span class="keyword">if</span> (hasNan)
  <span class="comment">% Remove NaNs from data, interpolate the missing values and plot</span>
  warning(<span class="string">'Data has missing value(s) in it!'</span>)
  interpData = zeros(nRow, nCol); <span class="comment">%var. to assign interpolated vals</span>
  figure; <span class="comment">%create new figure to plot the interpolated data</span>

  <span class="keyword">for</span> iCol = 1:nCol <span class="comment">%loop over columns of data</span>
    <span class="comment">%utilize logical indexing to find the row-subscripts of valid data</span>
    cleanSubs = ~isnan( missData(:, iCol) );
    cleanVals = missData(cleanSubs, iCol);
    <span class="comment">% Interpolate the values at query points in 't' vector</span>
    interpData(:, iCol) = interp1q( t(cleanSubs), cleanVals, t);

    <span class="comment">% Plot each interpolated column data one after another</span>
    plot( t, interpData(:, iCol), <span class="string">'-*'</span>, <span class="string">'LineWidth'</span>, 2);
    hold <span class="string">on</span>; <span class="comment">%keep the plotted lines on the figure</span>
  <span class="keyword">end</span>

  <span class="comment">% Set graph properties</span>
  xlabel(xAxisName), ylabel(yAxisName),
  title( horzcat(<span class="string">'Cleaned-up and Interpolated '</span>, graphName) );
  legend(lineName, <span class="string">'Location'</span>, <span class="string">'north'</span>); hold <span class="string">off</span>;
<span class="keyword">end</span>
</pre><pre class="codeoutput">Warning: Data has missing value(s) in it! 
</pre><img vspace="5" hspace="5" src="demoENG101_02.png" alt=""> <img vspace="5" hspace="5" src="demoENG101_03.png" alt=""> <h2 id="7">Computing RMS Error of interpolation with vectorized vs. looped code</h2><p>We will compute root mean squared error (RMSE) of interpolation for missing vals in two different approaches.</p><pre class="codeinput">timerRmse = zeros(1, 2); <span class="comment">%initialize timer variable</span>

<span class="comment">% We will also measure and compare the time these approaches take:</span>
tic; <span class="comment">%time the vectorized approach in computing rmsErr</span>
rmsErr = sqrt( 1/nRow * sum( ( interpData - rawData ).^2 ) );
timerRmse(1) = toc;

tic; <span class="comment">%time the looped approach in computing rmsErr</span>
<span class="keyword">for</span> iCol = 1:nCol
  rmsErr(iCol) = sqrt( 1/nRow * <span class="keyword">...</span>
                       sum( ( interpData(:, iCol) - <span class="keyword">...</span>
                       rawData(:, iCol) ).^2 ) );
<span class="keyword">end</span>
timerRmse(2) = toc;
<span class="comment">% Report RMSE of interpolated vals. with respect to original data</span>
fprintf( [<span class="string">'RMSE between the interpolated and original data: '</span>, <span class="keyword">...</span>
          <span class="string">'%.2f  %.2f  %.2f \n'</span>], rmsErr(:) );
<span class="comment">% Compare elapsed time using vectorized vs. looped code</span>
fprintf( [<span class="string">'\nRatio of elapsed time to compute RMSE -&gt; '</span>, <span class="keyword">...</span>
          <span class="string">'Vectorized / Looped: %.2f'</span>], timerRmse(1)/timerRmse(2) );
</pre><pre class="codeoutput">RMSE between the interpolated and original data: 8.49  10.32  14.02 

Ratio of elapsed time to compute RMSE -&gt; Vectorized / Looped: 0.37</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%==========================================================================
% Name        : demoENG101.m
% Author      : Mert Turkol
% Date        : 07/30/2018
% Copyright   : GNU General Public License
% Description : This script executes the statements and expressions
%               presented in the video demonstration for ENG101 GSI
%               application. The examples demonstrated by this code 
%               mainly cover simple yet important Data Handling 
%               basics. During the demo we will also talk about 
%               various topics like array manipulation, random# 
%               generation and logical indexing as well as some 
%               efficient code-writing practices (i.e. vectorization)
%==========================================================================
%% Loading and displaying data
% Load some data from a space-delimited file that comes preinstalled with
% MATLAB: Three sets of hourly traffic counts, recorded at three different 
% town intersections over a 24-hour period.       
rawData = load('count.dat'); %also works for comma-separated txt files
% for excel spreadsheets, use: xlsData = xlsread('someFile.xls') or 
% for csv comma-separated files, use: csvData = csvread('someFile.csv')
whos rawData %list chosen variable name, size and type
disp(rawData) %display the data
%% Plotting data
[nRow, nCol] = size(rawData);
t = (1:nRow)'; %time vector with unit hourly increments
% General expression for 'n' samples between 'tStart' and 'tFinal' is: 
% t = tStart:(tFinal-tStart)/(n-1):tFinal;
hRaw = plot(t, rawData, '-*', 'LineWidth', 2); %store plot handle
graphName = 'Traffic Count Data'; title(graphName);
xAxisName = 'Time [h]'; xlabel(xAxisName), 
yAxisName = 'Vehicle Count'; ylabel(yAxisName), 
lineName = ['Intersection 1'; 'Intersection 2'; 'Intersection 3'];
legend(lineName, 'Location', 'north');
%% Making a scenario: Random missing values in data
% Let's randomly contaminate data by replacing two entries in each column 
% with 'NaN's (Not-a-Number) on purpose to simulate missing data behavior. 
% 'NaN's appear as a result of undefined operation, such as 0/0.
SEEDVAL = 734; rng(SEEDVAL); %set random seed for repeatibility
NMISS = 2; rndmSubs = randi([2 nRow-1], [NMISS nCol]);
% randi([startVal endVal], [size1 size2 ... sizeN] draws random ints 
% from the uniform distribution btwn. startVal - endVal, and returns 
% [size1 x ... x sizeN] array. 

% NOTE: 'rand()' draws real numbers from the uni. distro., whereas 
%       'randn()' does the same from normal distro.

% Along the same column, we would like two row-subscripts chosen 
% randomly to be different to prevent replacing the same entry twice.
% First, take successive differences along the rows of 'rndmSubs'.
isUnique = all( diff(rndmSubs) );  
% The resulting row vector is then evaluated and returns '1' 
% if and only if ALL differences are non-zero. This will be the 
% loop condition to make sure we have unique row-subscripts 
% selected along each column.

% NOTE: any( x ) returns 1 if ANY entry is nonzero

while(~isUnique) %iterate until condition is false
  disp('Random matrix of integer subscripts with equal values along column(s):'); 
  disp(rndmSubs);
  %randomly shuffle the array:
  rndmSubs = rndmSubs( randperm( numel(rndmSubs) ) );
  %reshape vector into a matrix:
  rndmSubs = reshape(rndmSubs, NMISS, []); 
  %assign the new value of loop-variable:
  isUnique = all( diff(rndmSubs) );
end

% We randomly chose two integer subscripts in the [2, 23] interval 
% to replace two entries with corresponding row indices along each
% column of rawData. rndmSubs is of size [2x3] and has non-equal 
% integers within each column.
disp('Unique integer subscripts to replace with NaNs in each column: '); 
disp(rndmSubs);

% Alteratively, we could display our matrix of random integers 
% that are unique per column, with fprintf() :
% fprintf( [ '\nUnique integer subscripts to replace with NaNs ', ...
%            'in each column: \n', ...
%            repmat('\t\t%d  %d  %d\n', 1, NMISS) ], rndmSubs' );
%% Replacing data with missing values        
missData = rawData; %define a new data matrix same as the original 
for iCol = 1:nCol %loop over columns of data
 missData( rndmSubs(:,iCol), iCol ) = nan; %replace with NaN
end 

%% Pre-process, clean and interpolate data
% We will now plot the data with missing values to see what it looks like.
% Assuming no previous knowledge about the contaminated data's content
% (except its size), we will identify where the missing values are. Final
% step will be to clean those values and estimate w/ linear interpolation.
hold on; delete(hRaw);  legend('off'); plot(t, missData, '-*', 'LineWidth', 2); 
title( horzcat('Missing ', graphName) ); hold off; 

hasNan = any( isnan( missData(:) ) ); %logical to check for NaNs
if (hasNan)
  % Remove NaNs from data, interpolate the missing values and plot  
  warning('Data has missing value(s) in it!')
  interpData = zeros(nRow, nCol); %var. to assign interpolated vals  
  figure; %create new figure to plot the interpolated data
  
  for iCol = 1:nCol %loop over columns of data
    %utilize logical indexing to find the row-subscripts of valid data
    cleanSubs = ~isnan( missData(:, iCol) ); 
    cleanVals = missData(cleanSubs, iCol); 
    % Interpolate the values at query points in 't' vector  
    interpData(:, iCol) = interp1q( t(cleanSubs), cleanVals, t);
    
    % Plot each interpolated column data one after another
    plot( t, interpData(:, iCol), '-*', 'LineWidth', 2); 
    hold on; %keep the plotted lines on the figure        
  end
  
  % Set graph properties
  xlabel(xAxisName), ylabel(yAxisName), 
  title( horzcat('Cleaned-up and Interpolated ', graphName) );
  legend(lineName, 'Location', 'north'); hold off;    
end

%% Computing RMS Error of interpolation with vectorized vs. looped code
% We will compute root mean squared error (RMSE) of interpolation 
% for missing vals in two different approaches. 
timerRmse = zeros(1, 2); %initialize timer variable

% We will also measure and compare the time these approaches take: 
tic; %time the vectorized approach in computing rmsErr
rmsErr = sqrt( 1/nRow * sum( ( interpData - rawData ).^2 ) );
timerRmse(1) = toc;

tic; %time the looped approach in computing rmsErr
for iCol = 1:nCol
  rmsErr(iCol) = sqrt( 1/nRow * ...
                       sum( ( interpData(:, iCol) - ...
                       rawData(:, iCol) ).^2 ) ); 
end
timerRmse(2) = toc;  
% Report RMSE of interpolated vals. with respect to original data
fprintf( ['RMSE between the interpolated and original data: ', ...
          '%.2f  %.2f  %.2f \n'], rmsErr(:) );
% Compare elapsed time using vectorized vs. looped code
fprintf( ['\nRatio of elapsed time to compute RMSE -> ', ...
          'Vectorized / Looped: %.2f'], timerRmse(1)/timerRmse(2) );
##### SOURCE END #####
--></body></html>